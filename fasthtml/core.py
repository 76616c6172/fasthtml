# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['empty', 'htmx_hdrs', 'date', 'snake2hyphens', 'RouteX', 'RouterX', 'FastHTML', 'reg_re_param']

# %% ../nbs/00_core.ipynb 2
import json, dateutil

from fastcore.utils import *
from fastcore.xml import *

from types import UnionType, SimpleNamespace as ns
from typing import Optional, get_type_hints, get_args, get_origin, Union, Mapping
from datetime import datetime
from dataclasses import dataclass,fields,is_dataclass,MISSING,asdict
from inspect import isfunction,ismethod,signature,Parameter
from functools import wraps, partialmethod

from starlette.applications import Starlette
from starlette.routing import Route, Mount, Router
from starlette.responses import Response, HTMLResponse, FileResponse, JSONResponse
from starlette.requests import Request
from starlette.staticfiles import StaticFiles
from starlette.exceptions import HTTPException
from starlette._utils import is_async_callable
from starlette.convertors import Convertor, StringConvertor, register_url_convertor, CONVERTOR_TYPES

# %% ../nbs/00_core.ipynb 4
empty = Parameter.empty

# %% ../nbs/00_core.ipynb 5
def _wrap_resp(resp, cls):
    if isinstance(resp, Response): return resp
    if cls is not empty: return cls(resp)
    if isinstance(resp, (list,tuple)): return HTMLResponse(to_xml(resp))
    if isinstance(resp, str): cls = HTMLResponse 
    elif isinstance(resp, Mapping): cls = JSONResponse 
    else:
        resp = str(resp)
        cls = HTMLResponse
    return cls(resp)

# %% ../nbs/00_core.ipynb 6
def _fix_anno(t):
    origin = get_origin(t)
    if origin is Union or origin is UnionType:
        t = first(o for o in get_args(t) if o!=type(None))
    if t==bool: return str2bool
    return t

# %% ../nbs/00_core.ipynb 7
def date(s): return dateutil.parser.parse(s)

# %% ../nbs/00_core.ipynb 8
def _form_arg(fld, body):
    res = body.get(fld.name, None)
    if not res: res = fld.default
    assert res is not MISSING
    anno = _fix_anno(fld.type)
    if res is not None: res = anno(res)
    return res

# %% ../nbs/00_core.ipynb 9
async def _from_body(req, arg, p):
    body = await req.form()
    cargs = {o.name:_form_arg(o, body) for o in fields(p.annotation)}
    return p.annotation(**cargs)

# %% ../nbs/00_core.ipynb 10
def snake2hyphens(s):
    s = snake2camel(s)
    return camel2words(s, '-')

# %% ../nbs/00_core.ipynb 11
htmx_hdrs = dict(
    boosted="HX-Boosted",
    current_url="HX-Current-URL",
    history_restore_request="HX-History-Restore-Request",
    prompt="HX-Prompt",
    request="HX-Request",
    target="HX-Target",
    trigger_name="HX-Trigger-Name",
    trigger="HX-Trigger")

def _get_htmx(req):
    res = {k:req.headers.get(v.lower(), None) for k,v in htmx_hdrs.items()}
    return ns(**res) if res else None

# %% ../nbs/00_core.ipynb 12
async def _find_p(req, arg:str, p):
    if p.annotation is empty:
        if 'request'.startswith(arg.lower()): return req
        if arg.lower()=='htmx': return _get_htmx(req)
        return None
    if is_dataclass(p.annotation): return await _from_body(req, arg, p)
    res = req.path_params.get(arg, None)
    if not res: res = req.query_params.get(arg, None)
    if not res: res = req.cookies.get(arg, None)
    if not res: res = req.headers.get(snake2hyphens(arg), None)
    if not res: res = p.default
    if res is empty: return None
    anno = _fix_anno(p.annotation)
    if res is not None and anno is not empty: res = anno(res)
    return res

# %% ../nbs/00_core.ipynb 13
async def _wrap_req(req, params):
    if not params: return []
#     items = [(k,v) for k,v in params.items()
#              if v.annotation is not empty or v.default is not empty]
#     if len(params)==1 and not items: return [req]
    return [await _find_p(req, arg, p) for arg,p in params.items()]

# %% ../nbs/00_core.ipynb 14
def _wrap_ep(f):
    if not (isfunction(f) or ismethod(f)): return f
    sig = signature(f)
    params = sig.parameters
    cls = sig.return_annotation

    async def _f(req):
        req = await _wrap_req(req, params)
        resp = f(*req)
        if is_async_callable(f): resp = await resp
        return _wrap_resp(resp, cls)
    return _f

# %% ../nbs/00_core.ipynb 15
class RouteX(Route):
    def __init__(self, path, endpoint, *args, **kw):
        ep = _wrap_ep(endpoint)
        super().__init__(path, ep, *args, **kw)

# %% ../nbs/00_core.ipynb 16
class RouterX(Router):
    def add_route( self, path: str, endpoint: callable, methods=None, name=None, include_in_schema=True):
        route = RouteX(path, endpoint=endpoint, methods=methods, name=name, include_in_schema=include_in_schema)
        self.routes.append(route)

# %% ../nbs/00_core.ipynb 17
class FastHTML(Starlette):
    def __init__(self, debug=False, routes=None, middleware=None, exception_handlers=None,
                 on_startup=None, on_shutdown=None, lifespan=None):
        super().__init__(debug, routes, middleware, exception_handlers, on_startup, on_shutdown, lifespan=lifespan)
        self.router = RouterX(routes, on_startup=on_startup, on_shutdown=on_shutdown, lifespan=lifespan)

    def route(self, path:str, methods=None, name=None, include_in_schema=True):
        if isinstance(methods,str): methods=[methods]
        def f(func):
            self.router.add_route(path, func, methods=methods, name=name, include_in_schema=include_in_schema)
            return func
        return f

for o in 'get post put delete patch head trace options'.split():
    setattr(FastHTML, o, partialmethod(FastHTML.route, methods=o.capitalize()))

# %% ../nbs/00_core.ipynb 18
def reg_re_param(m, s):
    cls = get_class(f'{m}Conv', sup=StringConvertor, regex=s)
    register_url_convertor(m, cls())

# Starlette doesn't have the '?', so it chomps the whole remaining URL
reg_re_param("path", ".*?")
